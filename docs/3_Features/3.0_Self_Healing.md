# Self-Healing Layouts

> **Automatic layout repair with ML prediction and neural healing**

Trinity's self-healing system combines machine learning prediction with intelligent CSS repair to automatically fix layout issues.

---

## Overview

Traditional approach: Build → Test → Fix → Rebuild (slow, manual)

Trinity approach: **Predict → Prevent → Heal** (fast, automated)

### Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Self-Healing Pipeline                     │
└─────────────────────────────────────────────────────────────┘

┌──────────────┐      ┌──────────────┐      ┌──────────────┐
│  PREDICTOR   │─────▶│   GUARDIAN   │─────▶│    HEALER    │
│  (Prevent)   │      │   (Detect)   │      │   (Repair)   │
│              │      │              │      │              │
│ Random Forest│      │  Playwright  │      │ LSTM + Rules │
│  15 features │      │  Visual QA   │      │ CSS Fixes    │
│  87% accuracy│      │  95% detect  │      │ 78% success  │
└──────────────┘      └──────────────┘      └──────────────┘
       │                      │                      │
       ▼                      ▼                      ▼
  Risk < 0.4           Layout broken?          Apply fix
  Skip Guardian        Yes → Heal              Rebuild
```

---

## Predictor (Layer 3)

### Purpose

Predict layout breakage probability **before** rendering to avoid expensive Guardian validation.

### Model Architecture

**Random Forest Classifier:**
- 100 decision trees
- Max depth: 10
- Training data: 1000+ real build events
- Features: 15 content and theme metrics

### Feature Engineering

The predictor analyzes 15 features:

**Content Metrics (7 features):**
```python
features = {
    "content_length": len(full_content),        # Total characters
    "max_title_length": max(len(t) for t in titles),
    "max_description_length": max(len(d) for d in descriptions),
    "avg_word_length": sum(lens) / len(words),
    "has_long_words": any(len(w) > 20 for w in words),
    "has_repeating_chars": bool(re.search(r'(.)\1{4,}', content)),
    "card_count": len(content.get("projects", []))
}
```

**Text Analysis (4 features):**
```python
features = {
    "special_char_ratio": special_chars / total_chars,
    "number_ratio": numbers / total_chars,
    "uppercase_ratio": uppercase / total_chars,
    "whitespace_ratio": whitespace / total_chars
}
```

**Theme Metrics (3 features):**
```python
features = {
    "theme_complexity": len(theme_classes),
    "layout_density": content_length / estimated_pixels,
    "estimated_render_time": content_length * theme_factor / 1000
}
```

**Statistical Features (1 feature):**
```python
from math import log2

# Shannon entropy - measures content randomness
def entropy(text):
    freq = Counter(text)
    probs = [f / len(text) for f in freq.values()]
    return -sum(p * log2(p) for p in probs if p > 0)

features["content_entropy"] = entropy(content)
```

### Prediction Flow

```python
from trinity.components.predictor import LayoutRiskPredictor

# 1. Load trained model
predictor = LayoutRiskPredictor.load("models/layout_risk_predictor.pkl")

# 2. Extract features
features = predictor.extract_features(content, theme)

# 3. Predict risk
risk_score = predictor.predict_proba(features)[0][1]

# 4. Decision logic
if risk_score > 0.7:
    logger.warning(f"High risk detected: {risk_score:.2f}")
    enable_guardian = True
elif risk_score > 0.4:
    logger.info(f"Medium risk: {risk_score:.2f}")
    enable_guardian = optional  # User configurable
else:
    logger.info(f"Low risk: {risk_score:.2f}, skipping Guardian")
    enable_guardian = False
```

### Model Performance

| Metric | Value | Description |
|--------|-------|-------------|
| **Accuracy** | 87% | Overall correct predictions |
| **Precision** | 82% | Few false positives (unnecessary Guardian runs) |
| **Recall** | 91% | Catches most real issues |
| **F1 Score** | 0.86 | Balanced precision/recall |
| **Inference Time** | <10ms | Fast predictions |

**Impact:**
- Reduces Guardian usage by 60%
- Saves 2-3 seconds per low-risk build
- Improves developer experience

### Training Your Own Model

**Collect training data:**

```bash
# Build with data collection enabled
python main.py --theme brutalist --collect-metrics

# After many builds, you'll have data/training_dataset.csv
```

**Train model:**

```bash
# Quick training (fast)
make train

# Or use training script
python scripts/fast_training.sh
```

**Evaluate model:**

```python
from trinity.components.trainer import ModelTrainer

trainer = ModelTrainer("data/training_dataset.csv")
metrics = trainer.evaluate_model()

print(f"Accuracy: {metrics['accuracy']:.2%}")
print(f"Precision: {metrics['precision']:.2%}")
print(f"Recall: {metrics['recall']:.2%}")
```

---

## Guardian (Layer 5)

### Purpose

Visual validation using browser automation to detect actual layout issues.

### Playwright Integration

**Detection capabilities:**
- Text overflow (horizontal scrolling)
- Container overflow
- Element positioning issues
- Visual regression (screenshot comparison)
- Responsive breakpoint failures

### Detection Algorithm

```python
async def detect_overflows(page: Page) -> List[OverflowError]:
    """Detect text overflow in rendered page"""
    
    # 1. Find all text elements
    elements = await page.query_selector_all("h1, h2, h3, p, span")
    
    overflows = []
    for el in elements:
        # 2. Get element dimensions
        box = await el.bounding_box()
        scroll_width = await el.evaluate("el => el.scrollWidth")
        client_width = await el.evaluate("el => el.clientWidth")
        
        # 3. Check for overflow (5px tolerance)
        if scroll_width > client_width + 5:
            overflow_amount = scroll_width - client_width
            
            overflows.append({
                "element": await el.evaluate("el => el.className"),
                "overflow_px": overflow_amount,
                "text": await el.text_content(),
                "location": box
            })
    
    return overflows
```

### Usage Modes

**Mode 1: Always On (Development)**
```bash
# Validate every build
python main.py --theme brutalist --guardian
```

**Mode 2: Risk-Based (Recommended)**
```python
# Only validate high-risk builds
if predictor.risk_score > 0.7:
    enable_guardian = True
else:
    enable_guardian = False
```

**Mode 3: Disabled (CI/CD)**
```bash
# Skip visual validation for speed
python main.py --no-guardian
```

### Performance Characteristics

| Operation | Time | Notes |
|-----------|------|-------|
| Browser launch | 1.0s | Cached after first run |
| Page load | 0.8s | Depends on content size |
| Validation | 0.7s | DOM inspection |
| **Total** | **2.5s** | Per validation |

**Optimization:**
- Reuse browser instances
- Skip validation on low-risk builds (60% reduction)
- Parallel validation for multiple themes

---

## Healer (Layer 4)

### Purpose

Automatically fix layout issues detected by Guardian using hybrid neural + heuristic approach.

### Hybrid Architecture

**Neural Healer (v0.5.0+):**
- LSTM Seq2Seq model
- 270K parameters
- Context-aware CSS generation
- 78% first-attempt success rate

**SmartHealer (Fallback):**
- Rule-based strategies
- Guaranteed to work
- Fast execution (<50ms)
- Used when neural model unavailable

### Neural Healer

**Model Architecture:**

```
Encoder (Problem Context):
  Input: [theme_id, error_type, content_length]
  Embedding: 64 dimensions
  LSTM: 2 layers × 128 hidden units
  Output: Context vector (128D)

Decoder (Fix Generation):
  Input: Context vector + previous token
  LSTM: 2 layers × 128 hidden units
  Attention: Over encoder states
  Output: Tailwind CSS class tokens
  Vocabulary: 500 most common Tailwind classes
```

**Training Data:**

```python
# Example training pairs
training_data = [
    {
        "context": {
            "theme": "brutalist",
            "error_type": "overflow",
            "content_length": 87
        },
        "input_css": "text-6xl font-black",
        "output_css": "text-5xl font-bold break-words"
    },
    # ... 5000+ examples
]
```

**Usage:**

```python
from trinity.components.neural_healer import NeuralHealer

# Load model with fallback
healer = NeuralHealer.from_default_paths(fallback_to_heuristic=True)

# Generate fix
fix = healer.heal_layout(
    guardian_report=audit_result,
    content=content,
    context={
        "theme": "brutalist",
        "error_type": "overflow",
        "content_length": 87
    }
)

# Apply fix
apply_css_fix(html, fix)
```

### SmartHealer (Heuristic)

**Strategy 1: CSS_BREAK_WORD**

Problem: Long unbreakable words overflow container

```css
/* Before */
.card-title {
  overflow: hidden;
}

/* After */
.card-title {
  word-break: break-word;
  overflow-wrap: break-word;
  hyphens: auto;
}
```

**Strategy 2: FONT_SHRINK**

Problem: Text too large for container

```css
/* Before */
.hero-title {
  font-size: 4rem;
}

/* After */
.hero-title {
  font-size: 3rem;
  line-height: 1.2;
}
```

**Strategy 3: CONTAINER_EXPAND**

Problem: Fixed-width container too narrow

```css
/* Before */
.card {
  width: 300px;
  padding: 1rem;
}

/* After */
.card {
  min-width: 300px;
  width: auto;
  max-width: 100%;
  padding: 1rem;
}
```

**Strategy 4: TRUNCATE**

Problem: Single-line text wrapping

```css
/* Before */
.subtitle {
  /* Text wraps */
}

/* After */
.subtitle {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
```

**Strategy 5: GRID_ADJUST**

Problem: Grid items breaking layout

```css
/* Before */
.project-grid {
  grid-template-columns: repeat(3, 1fr);
}

/* After */
.project-grid {
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 2rem;
}
```

### Healing Pipeline

```python
def self_healing_loop(content, theme, max_retries=3):
    """Self-healing build loop"""
    
    for attempt in range(1, max_retries + 1):
        # 1. Build page
        html = build_page(content, theme)
        
        # 2. Validate with Guardian
        if not guardian_enabled:
            return html  # Skip validation
        
        audit = guardian.audit_layout(html)
        
        if audit["approved"]:
            logger.info("Layout approved")
            return html
        
        # 3. Generate fix
        logger.warning(f"Layout broken: {audit['reason']}")
        
        # Try neural healer first
        if neural_healer_available:
            fix = neural_healer.heal(audit, content, context)
            
            if fix.confidence > 0.6:
                logger.info(f"Neural fix (confidence: {fix.confidence})")
                html = apply_fix(html, fix)
                continue
        
        # Fallback to heuristic
        fix = smart_healer.heal(audit, content)
        logger.info(f"Heuristic fix: {fix.strategy}")
        html = apply_fix(html, fix)
    
    # Max retries exceeded
    logger.error("Failed to heal layout after 3 attempts")
    return html  # Return last attempt
```

---

## Performance Impact

### Phase 6 Self-Healing Metrics

| Metric | Before | After | Improvement |
|--------|--------|-------|-------------|
| **Guardian Usage** | 100% | 40% | 60% reduction |
| **Build Time (low risk)** | 5.0s | 2.5s | 2x faster |
| **Build Time (high risk)** | 8.0s | 7.5s | Minimal impact |
| **Fix Success Rate** | 65% | 78% | 20% improvement |
| **False Positives** | 15% | 5% | 67% reduction |

### Timing Breakdown

**Low-risk build (risk < 0.4):**
```
Content Generation:  1.2s
Theme Rendering:     0.3s
Risk Prediction:     0.01s  ← Fast ML inference
Guardian:            SKIPPED  ← 60% of builds
TOTAL:               1.5s
```

**High-risk build (risk > 0.7):**
```
Content Generation:  1.2s
Theme Rendering:     0.3s
Risk Prediction:     0.01s
Guardian Launch:     1.0s
Page Validation:     0.8s
Healing (if needed): 0.15s
Rebuild:             0.3s
TOTAL:               3.8s
```

---

## Configuration

**config/settings.yaml:**

```yaml
# Predictor configuration
predictor:
  enabled: true
  model_path: models/layout_risk_predictor.pkl
  
  # Risk thresholds
  thresholds:
    low: 0.4      # Below this: skip Guardian
    high: 0.7     # Above this: always use Guardian
    
# Guardian configuration
guardian:
  enabled: true
  headless: true
  timeout: 30000  # 30 seconds
  
  # Validation settings
  overflow_tolerance: 5  # pixels
  screenshot_compare: false
  
# Healer configuration
healer:
  mode: neural  # "neural", "heuristic", or "auto"
  
  neural:
    model_path: models/neural_healer.pth
    confidence_threshold: 0.6
    fallback_to_heuristic: true
  
  heuristic:
    max_retries: 3
    strategies:
      - CSS_BREAK_WORD
      - FONT_SHRINK
      - CONTAINER_EXPAND
      - TRUNCATE
      - GRID_ADJUST
```

---

## Next Steps

- [Neural-Symbolic Architecture](../1_Architecture/1.0_Neural_Symbolic.md) - Full pipeline details
- [Centuria Theme Factory](./3.1_Centuria_Factory.md) - Mass theme generation
- [LLM Caching](../4_LLM_Agents/4.0_LLM_Caching.md) - Response caching strategies
